/**
 * This code switches from STOPPED to DRIVING mode
 * when a button on the robot is pressed, then, after
 * traveling 0.5 meters as estimated by the encoders,
 * turns 90 degrees, as estimated by the gyroscope, then
 * travels another 0.5 meters. It continues this pattern
 * until a button is pressed, at which point it stops.
 * It also displays the distance traveled as estimated by
 * reading the encoders.
 */
target C {
    threading: false,
    build: "../scripts/build_nrf_unix.sh"   
};

import Display from "lib/Display.lf";
import EncoderToDistance from "lib/EncoderToDistance_Template.lf";
import GyroAngle from "lib/GyroAngle.lf";
import ArrowKeys from "BLE_Template.lf";

preamble {=
    // Include the functions for driving the robot
    // and reading its sensors.
    #include "lib/romi.h"
=}

reactor Robot {
    input drive:bool;       // Toggle mode.
    input distance:float;   // Distance input.
    
    output notify:string;   // Notify of mode change.
    state start_distance:float(0);   // Distance when entering DRIVING.
    state start_angle:float(0);
    gyro = new GyroAngle();
    keys = new ArrowKeys();

    reaction(startup) -> notify {=
        // Initialize the robot.
        APP_ERROR_CHECK(romi_init());
        lf_set(notify, "INIT");
    =}

    initial mode STOPPED {
        reaction(distance) {=
            // Set the start_distance in case there is a transition to DRIVING.
            self->start_distance = distance->value;
        =}
        reaction(drive) -> DRIVING, notify {=
            lf_set(notify, "STOPPED");
            romi_drive_direct(0, 0);

            if (drive->value) {
                lf_set_mode(DRIVING);
            }
        =}
    }

    mode DRIVING {
        reaction(distance, drive, gyro.z,keys.level) -> REVERSE_RIGHT, REVERSE_LEFT, TURN_RIGHT_180, notify {=
            // romi_drive_direct(110, 110);
            int defaultSpeed = 30;
            int leftspeed = defaultSpeed;
            int rightspeed = defaultSpeed;
                
            leftspeed = keys.level->value* defaultSpeed;
            rightspeed = keys.level->value* defaultSpeed;
            romi_drive_direct(leftspeed, rightspeed);
            //lf_set(notify, "DRIVING");
//        
//            if (leftcliff->value) {
//                self->start_distance = distance->value;
//                lf_set_mode(REVERSE_RIGHT);
//            } else if (rightcliff->value) {
//                self->start_distance = distance->value;
//                lf_set_mode(REVERSE_LEFT);
//            } else if (forwardcliff->value) {
//                self->start_distance = distance->value;
//                lf_set_mode(REVERSE_RIGHT);
//            } else if(plateau->value && !self->plateau_hit) {
//                self->plateau_hit = true;
//                self->start_angle = gyro.z->value;
//                lf_set_mode(TURN_RIGHT_180);
//            }

        =}
    }
    
    
    mode TURNING_LEFT {
        reaction(distance) {=
            // Set the start_distance in case there is a transition to DRIVING.
            self->start_distance = distance->value;
        =}
        reaction(gyro.z, drive) -> DRIVING, STOPPED, notify {=
            romi_drive_direct(-80, 80);
            lf_set(notify, "TURNING L");
           
            if (gyro.z->value - self->start_angle >= 45) {
                lf_set_mode(DRIVING);
            }

        =}
    }
    
    mode TURNING_RIGHT {
        reaction(distance) {=
            // Set the start_distance in case there is a transition to DRIVING.
            self->start_distance = distance->value;
        =}
        reaction(gyro.z, drive) -> DRIVING, STOPPED, notify {=
            romi_drive_direct(80, -80);
            lf_set(notify, "TURNING R");
            
            if (gyro.z->value - self->start_angle<= -45) {
                lf_set_mode(DRIVING);
            }

        =}
    }
    
}

main reactor {
    timer t(0, 100 msec);
    robot = new Robot();
    display = new Display();
    display2 = new Display(row = 1);
    converter = new EncoderToDistance();
    
    reaction(t) -> robot.drive, converter.encoder {=
        romi_sensors_t sensors;
        romi_sensors_poll(&sensors);
        if (romi_button_pressed(&sensors)) {
            lf_set(robot.drive, true);
        }
        
        // cliff detection
//        bool left = sensors.reflectance.left;
//        bool right = sensors.reflectance.right;
//        bool center = sensors.reflectance.right;
//        
//        bool rightcliff = !left && center && right;
//        bool forwardcliff = center && left && right;
//        bool nocliff = !center && !left && !right;
//        bool leftcliff = !rightcliff && !forwardcliff && !nocliff;
//        
//        lf_set(robot.rightcliff, rightcliff);
//        lf_set(robot.forwardcliff, forwardcliff);
//        lf_set(robot.nocliff, nocliff);
//        lf_set(robot.leftcliff, leftcliff);
        
        lf_set(converter.encoder, sensors.encoders.left);
        

    =}
    robot.notify -> display.message;
    converter.distance -> robot.distance;
        
    // reaction(converter.distance) -> display2.message {=
    //     static char y[BUCKLER_DISPLAY_WIDTH + 1];
    //     snprintf(y, BUCKLER_DISPLAY_WIDTH + 1, "distance:%3.3f", converter.distance->value);
    //     lf_set(display2.message, y);
    // =}
    
}
