/**
 * This code switches from STOPPED to DRIVING mode
 * when a button on the robot is pressed, then, after
 * traveling 0.5 meters as estimated by the encoders,
 * turns 90 degrees, as estimated by the gyroscope, then
 * travels another 0.5 meters. It continues this pattern
 * until a button is pressed, at which point it stops.
 * It also displays the distance traveled as estimated by
 * reading the encoders.
 */
 target C {
    threading: false,
    build: "../scripts/build_nrf_unix.sh"   
};

import Display from "lib/Display.lf";
import EncoderToDistance from "lib/EncoderToDistance_Template.lf";
import GyroAngle from "lib/GyroAngle.lf";

preamble {=
    // Include the functions for driving the robot
    // and reading its sensors.
    #include "lib/romi.h"
    static int num[4]={0};
=}

// Read the set point value from the keyboard;
reactor SpeedReader(period:time(100 msec)) {
    output speed_sp:float;
    printf("Please input the speed in the format of xxx.x\n");
    // Set the input of the speed in the certain format.
    // Otherwise, a timed automaton must be applied to detect whether two numbers are separate.
    scanf("%d%d%d.%d", &num[3], &num[2], &num[1], &num[0]);
    speed_sp->value = num[3]*100+num[2]*10 + num[1] + num[0]/10;
    //reaction(x, y, z) -> pitch, roll, tilt {=
    //=}
}


main reactor {
    //timer t(0, 100 msec);
    reader = new SpeedReader();
        
    reaction(reader.speed_sp) {=
        printf("Input speed:%f", reader.speed_sp->value);
    =}
}