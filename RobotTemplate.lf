/**
 * This code switches from STOPPED to DRIVING mode
 * when a button on the robot is pressed, then, after
 * traveling 0.5 meters as estimated by the encoders,
 * turns 90 degrees, as estimated by the gyroscope, then
 * travels another 0.5 meters. It continues this pattern
 * until a button is pressed, at which point it stops.
 * It also displays the distance traveled as estimated by
 * reading the encoders.
 */
 target C {
    threading: false,
    build: "../scripts/build_nrf_unix.sh"   
};

import Display from "lib/Display.lf";
import EncoderToDistance from "lib/EncoderToDistance_Template.lf";
import GyroAngle from "lib/GyroAngle.lf";

preamble {=
    // Include the functions for driving the robot
    // and reading its sensors.
    #include "lib/romi.h"
=}

reactor Robot {
    input drive:bool;       // Toggle mode to stop if false.
    input left_dis:float;   // Distance of the left wheel.
    input right_dis:float;   // Distance of the right wheel.
    //input speed_sp:float; // Setpoint of the speed;
    output left_speed_pv:float; // Process variable of speed, obtained from the encoder;
    output right_speed_pv:float;
    output notify:string;   // Notify of mode change.
//    state start_distance:float(0);   // Distance when entering DRIVING.
//    state temp_distance:float(0); // Temp variable in case we hit bump while in drive
    
    state dt:float(0.1); // The time of each period;
    // Same with the time in the main reactor.
    state pre_left_dis:float(0); // Previous distance of the left wheel.
    state pre_right_dis:float(0);
    state distance:float(0); // Distance between two turnings.
    // Using the left distance to represent the whole distance.
    state first:bool(true);   // Treat first distance input specially.
    
    reaction(startup) -> notify {=
        // Initialize the robot.
        APP_ERROR_CHECK(romi_init());
        lf_set(notify, "INIT");
    =}

    reaction(left_dis,right_dis) -> left_speed_pv, right_speed_pv {=
        if (self->first) {
            // First distance input, so speed should be zero.
            self->pre_left_dis = left_dis->value;
            self->pre_right_dis = right_dis->value;
            self->first = false;
            lf_set(left_speed_pv, 0);
            lf_set(right_speed_pv, 0);
        } 
        else {
            float diff = left_dis->value - self->pre_left_dis;
            // dx = current distance - previous distance;
            float speed = diff/self->dt;
            SET(left_speed_pv, speed);

            diff = right_dis->value - self->pre_right_dis;
            speed = diff/self->dt;
            SET(right_speed_pv, speed);

            // update the distance value;
            self->pre_left_dis = left_dis->value;
            self->pre_right_dis = right_dis->value;
        }    
     =}
    
    initial mode STOPPED {
        reaction(left_dis,drive) -> DRIVING, notify {=
            if (drive->is_present) {
                romi_drive_direct(75, 75);
                lf_set_mode(DRIVING);
                lf_set(notify, "DRIVING");
                self->distance = left_dis->value;
            }
        =}
    }

    mode DRIVING {

        reaction(left_dis, drive) -> reset(TURNING), STOPPED, notify {=
            if (!drive->is_present) {
                // Using the left distance to represent the whole distance.
                if (left_dis->value - self->distance > 0.5f) {
                    romi_drive_direct(-60, 60);
                    lf_set_mode(TURNING);
                    lf_set(notify, "TURNING");
                }
            } else {
                romi_drive_direct(0, 0);
                lf_set_mode(STOPPED);
                lf_set(notify, "STOPPED");
            }
        =}

    }
    
    mode TURNING {
        gyro = new GyroAngle();
        reaction(gyro.z, drive, left_dis) -> DRIVING, STOPPED, notify {=
            if (!drive->is_present) {
                if (gyro.z->value >= 85) {
                    romi_drive_direct(75, 75);
                    lf_set_mode(DRIVING);
                    lf_set(notify, "DRIVING");
                    // Count the distance from 0 again to avoid infinite loop of turning.
                    self->distance = left_dis->value;
                }
            } else {
                romi_drive_direct(0, 0);
                lf_set_mode(STOPPED);
                lf_set(notify, "STOPPED");
            }
        =}
    }
}

// Since the speed obtained from distance is not the same unit with the unit used in Romi Setting;
reactor SpeedCalibration(bias:float(0.0), sensitivity:float(681.2)) 
{
    input left:float;
    input right:float;
    output left_cal:float;
    output right_cal:float;
    reaction(left,right) -> left_cal, right_cal {=
        float l = self->sensitivity*left->value - self->bias;
        float r = self->sensitivity*right->value - self->bias;
        lf_set(left_cal, l);
        lf_set(right_cal, r);
    =}
}

main reactor {
    timer t(0, 100 msec);
    robot = new Robot();
    display = new Display();
    display2 = new Display(row = 1);
    converter_left = new EncoderToDistance();
    converter_right = new EncoderToDistance();
    Cal = new SpeedCalibration();
    reaction(t) -> robot.drive, converter_left.encoder, converter_right.encoder {=
        romi_sensors_t sensors;
        romi_sensors_poll(&sensors);
        if (romi_button_pressed(&sensors)) {
            lf_set(robot.drive, true);
        }

        lf_set(converter_left.encoder, sensors.encoders.left);
        lf_set(converter_right.encoder, sensors.encoders.right);
    =}
    robot.notify -> display.message;
    converter_left.distance -> robot.left_dis;
    converter_right.distance -> robot.right_dis;
    robot.left_speed_pv -> Cal.left;
    robot.right_speed_pv -> Cal.right;
        
    reaction(Cal.left_cal, Cal.right_cal) -> display2.message {=
        static char y[BUCKLER_DISPLAY_WIDTH + 1];
        snprintf(y, BUCKLER_DISPLAY_WIDTH + 1, "L:%3.1f R:%3.1f",
        Cal.left_cal->value, Cal.right_cal->value);
        lf_set(display2.message, y);
    =}
}