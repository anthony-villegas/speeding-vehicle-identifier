/**
 * This code switches from STOPPED to DRIVING mode
 * when a button on the robot is pressed, then, after
 * traveling 0.5 meters as estimated by the encoders,
 * turns 90 degrees, as estimated by the gyroscope, then
 * travels another 0.5 meters. It continues this pattern
 * until a button is pressed, at which point it stops.
 * It also displays the distance traveled as estimated by
 * reading the encoders.
 */
target C {
    threading: false,
    build: "../scripts/build_nrf_unix.sh"   
};

import Display from "lib/Display.lf";
import EncoderToDistance from "lib/EncoderToDistance_Template.lf";
import GyroAngle from "lib/GyroAngle.lf";

preamble {=
    // Include the functions for driving the robot
    // and reading its sensors.
    #include "lib/romi.h"
=}

reactor Robot {
    input drive:bool;       // Toggle mode.
    input distance:float;   // Distance input.
    input bump:bool; //false if bumped on left or center, true if bumped on right
    output notify:string;   // Notify of mode change.
    state start_distance:float(0);   // Distance when entering DRIVING.
    state temp_distance:float(0); //Temp variable in case we hit bump while in drive
    state bump_dir:bool; //false if bumped on left or center, true if bumped on right

    reaction(startup) -> notify {=
        // Initialize the robot.
        APP_ERROR_CHECK(romi_init());
        lf_set(notify, "INIT");
    =}

    initial mode STOPPED {
        reaction(distance) {=
            // Set the start_distance in case there is a transition to DRIVING.
            self->start_distance = distance->value;
        =}
        reaction(drive) -> DRIVING, notify {=
            if (drive->is_present) {
                romi_drive_direct(75, 75);
                lf_set_mode(DRIVING);
                lf_set(notify, "DRIVING");
            }
        =}
    }

    mode DRIVING {
        reaction(distance) {=
            self->temp_distance = distance->value;
        =}

        reaction(distance, drive) -> reset(TURNING), STOPPED, notify {=
            if (!drive->is_present) {
                if (distance->value - self->start_distance > 0.5f) {
                    romi_drive_direct(-60, 60);
                    lf_set_mode(TURNING);
                    lf_set(notify, "TURNING");
                }
            } else {
                romi_drive_direct(0, 0);
                lf_set_mode(STOPPED);
                lf_set(notify, "STOPPED");
            }
        =}

        reaction(bump, drive) -> reset(REVERSE), STOPPED, notify {=
            if(!drive->is_present) {
                self->bump_dir = bump->value;
                self->start_distance = self->temp_distance;
                romi_drive_direct(-75, -75);
                lf_set_mode(REVERSE);
                lf_set(notify, "REVERSE");
            } else {
                romi_drive_direct(0, 0);
                lf_set_mode(STOPPED);
                lf_set(notify, "STOPPED");
            }
        =}
    }
    
    mode TURNING {
        gyro = new GyroAngle();
        reaction(distance) {=
            // Set the start_distance in case there is a transition to DRIVING.
            self->start_distance = distance->value;
        =}
        reaction(gyro.z, drive) -> DRIVING, STOPPED, notify {=
            if (!drive->is_present) {
                if (gyro.z->value >= 85) {
                    romi_drive_direct(75, 75);
                    lf_set_mode(DRIVING);
                    lf_set(notify, "DRIVING");
                }
            } else {
                romi_drive_direct(0, 0);
                lf_set_mode(STOPPED);
                lf_set(notify, "STOPPED");
            }
        =}
    }

    mode REVERSE {
        reaction(distance, drive) -> reset(BUMP_TURNING), STOPPED, notify {=
            if (!drive->is_present) {
                if ((distance->value - self->start_distance) <= -0.1f) {
                    //state bump_dir:bool; //false if bumped on left or center, true if bumped on right
                    if(!self->bump_dir) {
                        romi_drive_direct(60, -60);
                        lf_set_mode(BUMP_TURNING);
                        lf_set(notify, "BUMP_TURNING");
                    }
                    else if(self->bump_dir) {
                        romi_drive_direct(-60, 60);
                        lf_set_mode(BUMP_TURNING);
                        lf_set(notify, "BUMP_TURNING");
                    }
                }
            } else {
                romi_drive_direct(0, 0);
                lf_set_mode(STOPPED);
                lf_set(notify, "STOPPED");
            }
        =}
    }

    mode BUMP_TURNING {
        gyro_2 = new GyroAngle();
        reaction(distance) {=
            // Set the start_distance in case there is a transition to DRIVING.
            self->start_distance = distance->value;
        =}
        reaction(gyro_2.z, drive) -> reset(DRIVING), STOPPED, notify {=
            if (!drive->is_present) {
                //state bump_dir:bool; //false if bumped on left or center, true if bumped on right
                if (!self->bump_dir && gyro_2.z->value <= -45) {
                    romi_drive_direct(75, 75);
                    lf_set_mode(DRIVING);
                    lf_set(notify, "DRIVING");
                }
                else if (self->bump_dir && gyro_2.z->value >= 45) {
                    romi_drive_direct(75, 75);
                    lf_set_mode(DRIVING);
                    lf_set(notify, "DRIVING");
                }
            } else {
                romi_drive_direct(0, 0);
                lf_set_mode(STOPPED);
                lf_set(notify, "STOPPED");
            }
        =}
    }
}

main reactor {
    timer t(0, 100 msec);
    robot = new Robot();
    display = new Display();
    display2 = new Display(row = 1);
    converter = new EncoderToDistance();
    reaction(t) -> robot.drive, robot.bump, converter.encoder {=
        romi_sensors_t sensors;
        romi_sensors_poll(&sensors);
        if (romi_button_pressed(&sensors)) {
            lf_set(robot.drive, true);
        }
        if (sensors.bumps.left || sensors.bumps.center) {
            lf_set(robot.bump, false);
        } else if(sensors.bumps.right) {
            lf_set(robot.bump, true);
        }

        lf_set(converter.encoder, sensors.encoders.left);
    =}
    robot.notify -> display.message;
    converter.distance -> robot.distance;
        
    reaction(converter.distance) -> display2.message {=
        static char y[BUCKLER_DISPLAY_WIDTH + 1];
        snprintf(y, BUCKLER_DISPLAY_WIDTH + 1, "distance:%3.3f", converter.distance->value);
        lf_set(display2.message, y);
    =}
}